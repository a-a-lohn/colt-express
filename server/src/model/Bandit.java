package model;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

import com.smartfoxserver.v2.protocol.serialization.SerializableSFSType;

// Start of user code for imports
// End of user code

/**
 * Bandit class definition. Generated by the TouchCORE code generator.
 */
public class Bandit implements SerializableSFSType {

	transient public Character character;
	public String characterAsString; //FOR NETWORKING
	transient public Hostage hostage;
	public String hostageAsString; //FOR NETWORKING
	public ArrayList<Loot> loot = new ArrayList<Loot>();
	public ArrayList<BulletCard> bullets = new ArrayList<BulletCard>();
	public ArrayList<Card> deck = new ArrayList<Card>(); //CONVENTION FOR DECK: POSITION DECK.SIZE() IS TOP OF DECK, POSITION 0 IS BOTTOM OF DECK
	public ArrayList<ActionCard> deckAC = new ArrayList<ActionCard>();
	public ArrayList<BulletCard> deckBC = new ArrayList<BulletCard>();
	public ArrayList<Card> hand = new ArrayList<Card>();
	public ArrayList<ActionCard> handAC = new ArrayList<ActionCard>();
	public ArrayList<BulletCard> handBC = new ArrayList<BulletCard>();
	public ActionCard toResolve = null;
	public int consecutiveTurnCounter = 0;

	//--EMPTY CONSTRUCTOR FOR SERIALIZATION--
	public Bandit() { }
	
	public Bandit(Character c) {
		this.character = c;
		this.characterAsString = c.toString();
		this.hostage = null;
	}
	
	public String getCharacterAsString() {
		return this.characterAsString;
	}

	public Character getCharacter(){
		return this.character;
	}


	public TrainUnit getPosition() {
		TrainUnit pos = GameManager.getInstance().banditPositions.get(this);
		return pos;
	}

	public void setPosition(TrainUnit tu) {
		GameManager.getInstance().banditPositions.replace(this.characterAsString, tu);
	}

	public boolean addLootAt(int index, Loot a) {
		boolean contains = loot.contains(a);
		if (contains) {
			return false;
		}
		loot.add(index, a);
		return true;
	}

	public void removeLootAt(int index) {
		if (this.loot.size() > index) {
			this.loot.remove(index);
		}
	}

	public Loot getLootAt(int index) {
		if (this.loot.size() > index){
			Loot a = this.loot.get(index);
			return a;
		}
		return null;
	}

	public void addLoot(Loot a) {
		boolean contains = this.loot.contains(a);
		if (contains) {
			return;
		}
		this.loot.add(a);
	}

	public void removeLoot(Loot a) {
		if (this.loot.contains(a)) {
			loot.remove(a);
		}
	}

	public boolean containsLoot(Loot a) {
		boolean contains = this.loot.contains(a);
		return contains;
	}

	public int sizeOfLoot() {
		int size = this.loot.size();
		return size;
	}

	public ArrayList<Loot> getLoot() {
		return this.loot;
	}

	public void addDeckAt(int index, Card a) {
		boolean contains = this.deck.contains(a);
		if (contains) {
			return;
		}
		this.deck.add(index, a);
		
		updateOtherDecks();
	}

	public Card removeDeckAt(int index) {
		assert this.deck.size() > index;
		Card c = this.deck.remove(index);
		
		updateOtherDecks();
		return c;
	}

	public Card getDeckAt(int index) {
		if (this.deck.size() > index) {
			return this.deck.get(index);
		}
		return null;
	}

	public void addDeck(Card a) {
		this.deck.add(a);
		updateOtherDecks();
	}

	public void removeDeck(Card a) {
		this.deck.remove(a);
		updateOtherDecks();
	}

	public boolean containsDeck(Card a) {
		boolean contains = this.deck.contains(a);
		return contains;
	}

	public int sizeOfDeck() {
		int size = this.deck.size();
		return size;
	}

	public ArrayList<Card> getDeck() {
		return this.deck;
	}

	public void addHandAt(int index, Card a) {
		boolean contains = hand.contains(a);
		if (contains) {
			return;
		}
		hand.add(index, a);
		updateOtherHands();
	}

	public void removeHandAt(int index) {
		if (this.hand.size() > index){
			this.hand.remove(index);
		}
		updateOtherHands();
	}

	public Card getHandAt(int index) {
		if (this.hand.size() > index) {
			Card a = this.hand.get(index);
			return a;
		}
		return null;
	}

	public void addHand(Card a) {
		this.hand.add(a);
		updateOtherHands();
	}

	public void removeHand(Card a) {
		this.hand.remove(a);
		updateOtherHands();
	}

	public boolean containsHand(Card a) {
		boolean contains = this.hand.contains(a);
		return contains;
	}

	public int sizeOfHand() {
		int size = this.hand.size();
		return size;
	}

	public ArrayList<Card> getHand() {
		return this.hand;
	}


	public Hostage getHostage() {
		return this.hostage;
	}

	public void setHostage(Hostage hostage) {
		this.hostage = hostage;
	}
	
	public String getHostageAsString() {
		return this.hostageAsString;
	}
	public void setHostageAsString(String hostage) {
		this.hostageAsString = hostage;
	}
	
	public ActionCard getToResolve() {
		return this.toResolve;
	}
	public void setToResolve(ActionCard ac) {
		this.toResolve = ac;
	}
	
	public int getConsecutiveTurnCounter() {
		return this.consecutiveTurnCounter;
	}
	public void setConsecutiveTurnCounter(int i) {
		this.consecutiveTurnCounter = i;
	}

	public void createStartingCards() {
		ActionCard acMove1 = new ActionCard(ActionType.MOVE, this.characterAsString);
		ActionCard acMove2 = new ActionCard(ActionType.MOVE, this.characterAsString);
		ActionCard acChangeFloor1 = new ActionCard(ActionType.CHANGEFLOOR, this.characterAsString);
		ActionCard acChangeFloor2 = new ActionCard(ActionType.CHANGEFLOOR, this.characterAsString);
		ActionCard acMarshal = new ActionCard(ActionType.MARSHAL, this.characterAsString);
		ActionCard acPunch = new ActionCard(ActionType.PUNCH, this.characterAsString);
		ActionCard acRob1 = new ActionCard(ActionType.ROB, this.characterAsString);
		ActionCard acRob2 = new ActionCard(ActionType.ROB, this.characterAsString);
		ActionCard acShoot1 = new ActionCard(ActionType.SHOOT, this.characterAsString);
		ActionCard acShoot2 = new ActionCard(ActionType.SHOOT, this.characterAsString);
		ActionCard acRide = new ActionCard(ActionType.RIDE, this.characterAsString);

		this.deck.add(acMove1);
		this.deck.add(acMove2);
		this.deck.add(acChangeFloor1);
		this.deck.add(acChangeFloor2);
		this.deck.add(acMarshal);
		this.deck.add(acPunch);
		this.deck.add(acRob1);
		this.deck.add(acRob2);
		this.deck.add(acShoot1);
		this.deck.add(acShoot2);
		this.deck.add(acRide);
		
		updateOtherDecks();
	}
	
	public void updateOtherDecks() {
		deckAC.clear();
		deckBC.clear();
		for(Card c : deck) {
			if(c instanceof ActionCard) {
				System.out.println("Adding an action card");
				deckAC.add((ActionCard) c);
			} else {
				System.out.println("Adding a bullet card");
				deckBC.add((BulletCard) c);
			}
		}
	}
	
	public void updateOtherHands() {
		handAC.clear();
		handBC.clear();
		for(Card c : hand) {
			if(c instanceof ActionCard) {
				System.out.println("Adding an action card");
				handAC.add((ActionCard) c);
			} else {
				System.out.println("Adding a bullet card");
				handBC.add((BulletCard) c);
			}
		}
	}
	

	public void createBulletCards() {

		BulletCard bc1 = new BulletCard(this.characterAsString);
		BulletCard bc2 = new BulletCard(this.characterAsString);
		BulletCard bc3 = new BulletCard(this.characterAsString);
		BulletCard bc4 = new BulletCard(this.characterAsString);
		BulletCard bc5 = new BulletCard(this.characterAsString);
		BulletCard bc6 = new BulletCard(this.characterAsString);

		this.bullets.add(bc1);
		this.bullets.add(bc2);
		this.bullets.add(bc3);
		this.bullets.add(bc4);
		this.bullets.add(bc5);
		this.bullets.add(bc6);
	}

	public BulletCard removeTopBullet() {
		return this.bullets.remove(this.bullets.size()-1);
	}
	
	public boolean bulletsIsEmpty() {
		return this.bullets.isEmpty();
	}
	
	public void createStartingPurse() {
		Money startingPurse = new Money(MoneyType.PURSE, 250);
		this.loot.add(startingPurse);
	}

}
