package model;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Optional;

import com.smartfoxserver.v2.protocol.serialization.SerializableSFSType;

// Start of user code for imports
// End of user code

/**
 * TrainUnit class definition.
 * Generated by the TouchCORE code generator.
 */
public class TrainUnit implements SerializableSFSType {
    
    protected CarType carType;
    
    protected Optional<TrainUnit> above = Optional.empty();
    protected Optional<TrainUnit> below = Optional.empty();
    protected Optional<TrainUnit> left = Optional.empty();
    protected Optional<TrainUnit> right = Optional.empty();
    protected Optional<TrainUnit> beside = Optional.empty(); //Used for stagecoach and it's adjacent car ONLY.
    
    protected boolean isMarshalHere = false;
    protected HashSet<Bandit> banditsHere = new HashSet<Bandit>();
    protected HashSet<Loot> lootHere = new HashSet<Loot>();
    protected HashSet<Horse> horsesHere = new HashSet<Horse>();
    
    private TrainUnit(CarType carType) {
    	this.carType = carType;
    	//TODO: createGraphic()
    }
    
    /**
     * 
     * @param numberOfBandits
     *           the number of train cars to create is based on the number of bandits playing the game
     * @return a 2D array laid out in the following configuration:
     *           train[0][i] = roof units
     *           train[1][i] = cabin units
     *           where i=0 is the caboose and i=number of cars is the locomotive
     * Does NOT contain the stagecoach. The GameManger must separately call createStagecoach().
     */
    static ArrayList<TrainUnit> createTrain(int numberOfBandits){
    	//Create one car for each player, +1 to account for the locomotive
    	final int trainLength = numberOfBandits + 1;
    	
    	TrainUnit[][] train = new TrainUnit[2][trainLength];
    	TrainUnit locoCabin = new TrainUnit(CarType.LocomotiveCabin);
    	TrainUnit locoRoof = new TrainUnit(CarType.LocomotiveRoof);
    	
    	//Create locomotive
    	locoCabin.above = Optional.of(locoRoof);
    	locoCabin.isMarshalHere = true;
    	locoRoof.below = Optional.of(locoCabin);
    	
    	//TODO: Add locomotive to array
    	
    	//TODO: Create rest of the cars, associate with each other, add to array
    	
    	//TODO: Associate locomotive to front car
    	
    }
    
    static TrainUnit createStagecoach() {
    	TrainUnit cabin = new TrainUnit(CarType.StagecoachCabin);
    	TrainUnit roof = new TrainUnit(CarType.StagecoachRoof);
    }


    
    /**
     * TRAIN UNIT METHODS
     */
    
    
    /**
     * 
     * @return
     */
    public TrainUnit getAbove() {
        if(this.above.isEmpty()) {
        	return null; //better design?
        }
        else {
        	return this.above.get();
        }
    }

    public TrainUnit getBelow() {
        if(this.below.isEmpty()) {
        	return null;
        }
        else {
        	return this.below.get();
        }
    }

    public TrainUnit getRight() {
        if(this.right.isEmpty()) {
        	return null;
        }
        else {
        	return this.right.get();
        }
    }

    public TrainUnit getLeft() {
        if(this.left.isEmpty()) {
        	return null;
        }
        else {
        	return this.left.get();
        }
    }

    public TrainUnit getBeside() {
        if(this.beside.isEmpty()) {
        	return null;
        }
        else {
        	return this.beside.get();
        }
    }
    
    public boolean isAdjacentTo(TrainUnit a) {
        //TODO
    	return false;
    }

    
    
    /**
     * BANDIT METHODS
     */
    
    
    /**
     * 
     * @param b
     *           b is a non-null Bandit to be added to this train car
     * @pre this train car must not already contain b
     */
    public void addBandit(Bandit b) {
    	assert !banditsHere.contains(b);
        //TODO
    }

    /**
     * 
     * @param b
     *           b is a non-null Bandit to be removed from this train car
     * @pre this train car must contain b
     */
    static boolean removeBandit(Bandit b) {
    	assert banditsHere.contains(b);
    	//TODO
    	return false;
    }

    boolean containsBandit(Bandit b) {
        return this.banditsHere.contains(a);
    }

    int numOfBanditsHere() {
        return this.banditsHere.size();
    }

    public HashSet<Bandit> getBandtsHere() {
        return this.banditsHere.clone();
    }

    
    /**
     * LOOT METHODS
     */
    
    
    /**
     * 
     * @param a
     */
    public void addLoot(Loot a) {
        //TODO
    }

    public void removeLoot(Loot a) {
        //TODO
    }

    boolean containsLoot(Loot a) {
        return this.lootHere.contains(a);
    }

    int numOfLootHere() {
        return this.lootHere.size();
    }

    public HashSet<Loot> getLootHere() {
        return this.lootHere.clone();
    }
    
    
    /**
     * MARSHAL METHODS
     */
    
    
    public boolean getIsMarshalHere() {
        return this.isMarshalHere;
    }

    public void setIsMarshalHere(boolean b) {
        this.isMarshalHere = b;
    }
    

    /**
     * HORSE METHODS, (HAVE NOT BEEN CHECKED)
     */
    
    
    public boolean addHorsesAt(int index, Horse a) {
        boolean contains = horses.contains(a);
        if (contains) {
            return false;
        }
        horses.add(index, a);
        return true;
    }

    public boolean removeHorsesAt(int index) {
        Horse removedElement = horses.remove(index);
        boolean result = removedElement != null;
        return result;
    }

    Horse getHorsesAt(int index) {
        Horse associated = horses.get(index);
        return associated;
    }

    boolean addHorses(Horse a) {
        boolean contains = horses.contains(a);
        if (contains) {
            return false;
        }
        boolean added = horses.add(a);
        return added;
    }

    boolean removeHorse(Horse a) {
        boolean removed = horses.remove(a);
        return removed;
    }

    boolean containsHorse(Horse a) {
        boolean contains = horses.contains(a);
        return contains;
    }

    int sizeOfHorses() {
        int size = horses.size();
        return size;
    }

    ArrayList<Horse> getHorses() {
        return this.horses;
    }
}
