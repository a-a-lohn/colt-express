package main;

import java.util.ArrayList;

import com.smartfoxserver.v2.protocol.serialization.SerializableSFSType;

// Start of user code for imports
// End of user code

/**
 * GameManager class definition.
 * Generated by the TouchCORE code generator.
 */
public class GameManager implements SerializableSFSType {
    
    protected static GameManager singleton;
    protected GameStatus gameStatus;
    protected Round currentRound;
    protected Bandit currentBandit;
    protected ArrayList<Round> rounds = new ArrayList<Round>();
    protected static Marshal marshalInstance;
    protected static PlayedPile playedPileInstance;
    protected TrainUnit[][] train;
    protected TrainUnit stagecoach;
    protected ArrayList<Bandit> bandits = new ArrayList<Bandit>();
    
    private GameManager GameManger(ArrayList<Bandit> bandits, Bandit currentBandit, ArrayList<Round> rounds, Round currentRound,
			GameStatus status, ArrayList<TrainUnit> trainUnits) {
        
        this.bandits = bandits;
		this.currentBandit = currentBandit;
		this.rounds = rounds;
		this.currentRound = currentRound;
		this.status = status;
		this.marshalInstance = Marshal.getInstance();
		this.playedPileInstance = PlayedPile.getInstance();
        
        this.train = TrainUnit.createTrain(this.bandits.size());
        this.stagecoach = TrainUnit.createStagecoach();
    }

    public static GameManger getInstance(){
        GameMananger gm = null;
        if(singleton = null){
            gm = new GameManager(new ArrayList<Bandit>(), null, new ArrayList<Round>(), null, GameStatus.SETUP,
					new ArrayList<TrainUnit>());
        }
        else{
            gm = GameManger.singleton;
        }
        return gm;
    }
    
    public Round getCurrentRound() {
        return this.currentRound;
    }

    public void setCurrentRound(Round newObject) {
        this.currentRound = newObject;
    }

    public Round getRoundAt(index){
        return this.rounds.get(index);
    }

    public void addRound(Round a) {
        int size = rounds.size();
        /*if (size == maximum) {
            return false;
        }*/
        this.rounds.add(a);
    }

    public void removeRound(Round a) {
        if (this.rounds.contains(a)) {
            this.rounds.remove(a);
        }
    }

    public boolean roundsContains(Round a) {
        boolean contains = rounds.contains(a);
        return contains;
    }

    public int sizeOfRounds() {
        int size = rounds.size();
        return size;
    }

    public ArrayList<Round> getRounds() {
        return this.rounds;
    }

    public void setGameStatus(GameStatus newStatus) {
        this.gameStatus = newStatus;
    }

    public GameStatus getGameStatus(){
        return this.gameStatus;
    }

    public void addTrainUnitsAt(int index, TrainUnit a) {
        boolean contains = this.trainUnits.contains(a);
        if (contains) {
            return;
        }
        trainUnits.add(index, a);
    }

    public void removeTrainUnitsAt(int index) {
        if (this.trainUnits.size >= index) {
            this.trainUnits.remove(index);
        }
    }

    public TrainUnit getTrainUnitsAt(int index) {
        if (this.trainUnits.size >= index) {
            return this.trainUnits.get(index);
        }
    }

    public void addTrainUnit(TrainUnit a) {
        this.trainUnits.add(a);
    }

    public void removeTrainUnits(TrainUnit a) {
        if (this.trainUnits.contains(a)){
            this.trainUnits.remove(a);
        }
    }

    public boolean trainUnitsContain(TrainUnit a) {
        boolean contains = trainUnits.contains(a);
        return contains;
    }

    public int sizeOfTrainUnits() {
        int size = this.trainUnits.size();
        return size;
    }

    public ArrayList<TrainUnit> getTrainUnits() {
        return this.trainUnits;
    }

    public Bandit getCurrentBandit() {
        return this.currentBandit;
    }

    public void setCurrentBandit(Bandit newObject) {
        this.currentBandit = newObject;
    }

    /*boolean addBanditsAt(int index, Bandit a) {
        int size = bandits.size();
        if (size == maximum) {
            return false;
        }
        bandits.add(index, a);
        return true;
    }*/

    public void removeBanditsAt(int index) {
        if (this.bandits.size()) >= index {
            this.bandits.remove(index);
        }
    }

    public Bandit getBanditsAt(int index) {
        if (this.bandits.size() >= index) {
            return this.bandits.get(index);
        }
    }


    public void addBandit(Bandit a) {
        bandits.add(a);
    }

    public void removeBandits(Bandit a) {
        if (this.bandits.contains(a)) {
            this.bandits.remove(a);
        }
    }

    public boolean containsBandits(Bandit a) {
        boolean contains = this.bandits.contains(a);
        return contains;
    }

    public int sizeOfBandits() {
        int size = this.bandits.size();
        return size;
    }

    public ArrayList<Bandit> getBandits() {
        return this.bandits;
    }

    boolean allPlayersChosen() {
		// TO DO
		// for all players, return if they are all associated with a bandit or not.
		return true;
	}

	int getNumOfPlayers() {
		// TO DO
		// Here to get number of players
		return 3;
	}

	void chosenCharacter(int playerId, Character c) {
		Bandit newBandit = new Bandit(c);
		this.bandits.add(newBandit);
		// TO DO.
		// Here to associate playerId with newBandit.
		boolean ready = this.allPlayersChosen();
		if (!ready) {
			System.out.println("Not all players are ready!");
		} else {
			int numP = this.getNumOfPlayers();
			for (int i = 0; i < numP; i++) {
				// Here create new TrainUnit object
				this.addTrainUnits(new TrainUnit());
			}

			for (Bandit b : this.bandits) {
				b.createStartingCards();
				b.createBulletCards();
				b.createStartingPurse();
			}
			
			// TO DO
			// set up positions for bandits correspondingly

			Marshal marshal = new Marshal();

			Money strongbox = new Money(MoneyType.STRONGBOX, 1000);
			
			// TO DO 
			// set up the positions for marshal and strongbox 
			
			for (TrainUnit tu : this.trainUnits) {
				// TO DO
				// algorithm for adding loots randomly to each train unit that is created
				// Money l = new Money();
				// tu.addLootInCabin(l);
			}

			this.setGameStatus(GameStatus.SCHEMIN);
			this.setCurrentRound(this.rounds.get(0));
			// set waiting for input to be true;
		}
	}
}
